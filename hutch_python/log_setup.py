"""
This module is used to set up and manipulate the ``logging`` configuration for
utilities like debug mode.
"""
import logging
import logging.config
import os
import sys
import threading
import time
from contextlib import contextmanager
from pathlib import Path

import pcdsutils.log
import yaml

from .constants import FILE_YAML

logger = logging.getLogger(__name__)


def setup_logging(dir_logs=None):
    """
    Sets up the ``logging`` configuration.

    Uses ``logging.yml`` to define the config
    and manages the ``log`` directory paths.

    Also sets up the standard pcds logstash handler.

    Parameters
    ----------
    dir_logs: ``str`` or ``Path``, optional
        Path to the log directory. If omitted, we won't use a log file.
    """
    with open(FILE_YAML, 'rt') as f:
        config = yaml.safe_load(f.read())

    if dir_logs is None:
        # Remove debug file from the config
        del config['handlers']['debug']
        config['root']['handlers'].remove('debug')
    else:
        # Ensure Path object
        dir_logs = Path(dir_logs)

        # Subdirectory for year/month
        dir_month = dir_logs / time.strftime('%Y_%m')

        # Make the log directories if they don't exist
        # Make sure each level is all permissions
        for directory in (dir_logs, dir_month):
            if not directory.exists():
                directory.mkdir()
                directory.chmod(0o777)

        user = os.environ['USER']
        timestamp = time.strftime('%d_%Hh%Mm%Ss')
        log_file = '{}_{}.{}'.format(user, timestamp, 'log')
        path_log_file = dir_month / log_file
        path_log_file.touch()
        config['handlers']['debug']['filename'] = str(path_log_file)

    # Configure centralized PCDS logging:
    pcdsutils.log.configure_pcds_logging()
    configure_excepthook_logging()

    logging.config.dictConfig(config)
    noisy_loggers = ['parso', 'pyPDB.dbd.yacc', 'ophyd', 'bluesky']
    hush_noisy_loggers(noisy_loggers)


def hush_noisy_loggers(modules, level=logging.WARNING):
    """
    Some loggers spam on INFO with no restraint, so we must raise their levels.

    It seems there is some disagreement over what log levels should mean. In
    our repos, INFO is used as the de-facto print replacement, but in some
    repos it is used as the secondary debug stream.
    """
    for module in modules:
        logging.getLogger(module).setLevel(level)


def get_session_logfiles():
    """
    Get the path to the current debug log file

    Returns
    -------
    logs : list
        List of absolute paths to log files that were created by this session.
        Returns an empty list if there is no ``RotatingFileHandler`` with the
        name ``debug``
    """
    # Grab the debug file handler
    try:
        handler = get_debug_handler()
    except RuntimeError:
        logger.warning("No debug RotatingFileHandler configured for session")
        return list()
    # Find all the log files that were generated by this session
    base = Path(handler.baseFilename)
    return [str(base.parent / log)
            for log in os.listdir(base.parent)
            if log.startswith(base.name)]


def get_console_handler():
    """
    Helper function to find the console ``StreamHandler``.

    Returns
    -------
    console: ``StreamHandler``
        The ``Handler`` that prints to the screen.
    """
    return get_handler('console')


def get_debug_handler():
    """
    Helper function to find the debug ``RotatingFileHandler``

    Returns
    -------
    debug: ``RotatingFileHandler``
        The ``Handler`` that prints to the log files
    """
    return get_handler('debug')


def get_handler(name):
    """
    Helper function to get an arbitrary `Handler`

    Returns
    -------
    hander : `Handler`
    """
    root = logging.getLogger('')
    for handler in root.handlers:
        if handler.name == name:
            return handler
    raise RuntimeError('No {} handler'.format(name))


def get_console_level():
    """
    Helper function to get the console's log level.

    Returns
    -------
    level: ``int``
        Compare to ``logging.INFO``, ``logging.DEBUG``, etc. to see which log
        messages will be printed to the screen.
    """
    handler = get_console_handler()
    return handler.level


def set_console_level(level=logging.INFO):
    """
    Helper function to set the console's log level.

    Parameters
    ----------
    level: ``int``
        Likely one of ``logging.INFO``, ``logging.DEBUG``, etc.
    """
    handler = get_console_handler()
    handler.level = level


def debug_mode(debug=None):
    """
    Enable, disable, or check if we're in debug mode.

    Debug mode means that the console's logging level is ``logging.DEBUG`` or
    lower, which means we'll see all of the internal log messages that usually
    are not sent to the screen.

    Parameters
    ----------
    debug: ``bool``, optional
        If provided, we'll turn debug mode on (``True``) or off (``False``)

    Returns
    -------
    debug: ``bool`` or ``None``
        Returned if `debug_mode` is called with no arguments. This is ``True`
        if we're in debug mode, and ``False`` otherwise.
    """
    if debug is None:
        level = get_console_level()
        return level <= logging.DEBUG
    elif debug:
        set_console_level(level=logging.DEBUG)
    else:
        set_console_level(level=logging.INFO)


@contextmanager
def debug_context():
    """
    Context manager for running a block of code in `debug_mode`.

    For example:

    .. code-block:: python

        with debug_context():
            buggy_function()
    """
    old_level = get_console_level()
    debug_mode(True)
    yield
    set_console_level(level=old_level)


def debug_wrapper(f, *args, **kwargs):
    """
    Wrapper for running a function in `debug_mode`.

    Parameters
    ----------
    f: ``function``
        Wrapped function to call

    *args:
        Function arguments

    **kwargs:
        Function keyword arguments
    """
    with debug_context():
        f(*args, **kwargs)


def configure_excepthook_logging(logger_name=None):
    """Install the exception handler to ship errors off to logstash."""
    do_not_log = (KeyboardInterrupt, SystemExit)

    if logger_name is not None:
        logger = logging.getLogger(logger_name)
    else:
        logger = pcdsutils.log.logger

    if getattr(sys.excepthook, '_pcds_', None):
        # Already installed; do not continue.
        return

    # The stashed excepthooks:
    _except_hook = sys.excepthook
    # This is technically Python 3.8+, but this should not interfere with
    # anything in earlier versions:
    _thread_except_hook = getattr(threading, 'excepthook', None)

    def excepthook(exc_type, exc_value, exc_traceback):
        if not issubclass(exc_type, do_not_log):
            logger.error('[exception] %s', exc_value,
                         exc_info=(exc_type, exc_value, exc_traceback))
        if _except_hook is not None:
            _except_hook(exc_type, exc_value, exc_traceback)

    def thread_excepthook(args):
        # https://docs.python.org/3/library/threading.html#threading.excepthook
        if not issubclass(args.exc_type, do_not_log):
            logger.error('[exception] (%s) %s', args.thread.name,
                         args.exc_value,
                         exc_info=(args.exc_type, args.exc_value,
                                   args.exc_traceback))
        if _thread_except_hook is not None:
            _thread_except_hook(args)

    # Indicator to not install twice:
    excepthook._pcds_ = True

    sys.excepthook = excepthook
    threading.excepthook = thread_excepthook
