"""
Automated Bug Reporting
"""
import os
import getpass
import logging
import textwrap
import tempfile
import warnings
import subprocess

from IPython.core.history import HistoryAccessor

from .log_setup import get_session_logfiles


logger = logging.getLogger(__name__)


# This function is aliased here so it can be easily be patched by the test
# suite. This allows us to eloquently simulate user inputted data
request_input = input


def get_current_environment():
    """
    Get the current CONDA environment

    The environment name is gathered by first checking environment variable
    ``$CONDA_ENVNAME`` that is set by the hutch-python startup scripts. If for
    whatever reason that is not available we check $CONDA_DEFAULT_ENV which is
    set by Conda itself. The reason this is not relied on primarily is it has a
    strange name and is entirely undocumented but seems to work effectively.

    In addition the hutch-python startup script sets the PYTHONPATH to pick up
    packages in "development" mode. The list of package names installed this
    way is found to help inform how the current Python environment differs from
    the enforced CONDA environment

    Returns
    -------
    env: str
        Name of environment

    dev_pkgs :list
        List of packages installed in the development folder
    """
    # Search for the environment variable set by the hutch python setup
    env = os.getenv('CONDA_ENVNAME')
    # Otherwise look for built-in Conda environment variables
    if not env:
        env = os.getenv('CONDA_DEFAULT_ENV')
    # Check the top level PYTHONPATH to see if we have packages installed in
    # development mode
    dev = os.getenv('PYTHONPATH')
    if dev:
        try:
            dev_pkgs = os.listdir(dev)
        except FileNotFoundError:
            logger.debug("No dev folder found")
    else:
        dev_pkgs = list()
    return env, dev_pkgs


def get_last_n_commands(n):
    """
    Find the last n commands entered in the IPython session

    Parameters
    ----------
    n : int
        Number of commands to retrieve

    Returns
    -------
    commands : str
        Block of text representing user input
    """
    # Ignore warnings generated by the HistoryAccessor. This can be removed
    # when https://github.com/ipython/ipython/pull/11054 reaches our release
    # environment
    with warnings.catch_warnings():
        warnings.simplefilter('ignore', UserWarning)
        ha = HistoryAccessor()
    return '\n'.join([cmd[2] for cmd in ha.get_tail(n, include_latest=True)])


def get_text_from_editor():
    """
    Request a description written in a text editor

    Opens a vim session with a prompt to request a detailed response from the
    operator.

    Returns
    -------
    text : str
        Block of text of the user input
    """
    with tempfile.NamedTemporaryFile(suffix='.tmp', mode='w+t') as f:
        # Create a temporary file with instructions on describing bug
        f.write(message + '\n\n')
        f.flush()
        # Open the editor and allow the user to type
        subprocess.call(['vim', f.name])
        # Read and clean the file
        f.seek(0)
        text = ''.join([line for line in f.readlines()
                        if line and not line.lstrip().startswith('#')])
        return textwrap.wrap(text, width=90)


def report_bug(title=None, description=None, author=None,
               prior_commands=None,
               captured_output=None):
    """
    Report a bug from the IPython session

    The purpose of this command is to collect the necessary information to
    later help diagnose and troubleshoot the issue. This is written as an
    interactive tool, but it can be used in a non-interactive way by entering
    the information on the call.

    By the end we should have gathered:

        * A brief description of the problem
        * The relevant commands to the bug report
        * Name of the current CONDA environment
        * Any packages installed in "development" mode
        * Relevant logfiles
        * Name of bug report author

    Parameters
    ----------
    title :str, optional
        One sentence description of the issue

    description : str, optional
        Written description of problem. If this is not provided, a text editor
        is launched that request the information from the user

    author : str, optional
        Name of bug report author. If not provided, this is requested from the
        user via command line

    prior_commands : int, optional
        Number of prior commands to capture. If this is not provided, this is
        requested from the user via command line.

    captured_output : str, optional
        Captured output from the command

    Returns
    -------
    report : dict
        A dictionary with the keys:

            * title
            * description
            * author
            * commands
            * env
            * logfiles
            * output
            * dev_pkgs
    """
    logger.debug("Reporting a bug from the IPython terminal ...")
    if not title:
        title = request_input('Please provide a one sentence description of '
                              'the problem you are encountering: ')
    # Grab relevant commands
    if not prior_commands:
        try:
            n = request_input("How many of the previous commands are relevant "
                              "to the issue you would like investigated?: ")
            prior_commands = int(n)
        except ValueError:
            logger.error("Invalid input %s", n)
            # Only select the last command by default
            prior_commands = 1
    # Grab specified number of commands
    commands = get_last_n_commands(prior_commands)
    # Get a more specific description
    description = description or get_text_from_editor()
    # Find the author
    if not author:
        author = request_input('Please enter a name so we can follow-up with '
                               'additional questions: ')
        author = author or getpass.getuser()
    # Gather environment information
    conda_env, dev_pkgs = get_current_environment()
    # Gather logfiles
    try:
        logfiles = get_session_logfiles()
    except RuntimeError:
        logger.warning("No debug RotatingFileHandler configured for session")
        logfiles = list()
    return {'title': title, 'author': author, 'commands': commands,
            'description': description, 'env': conda_env,
            'logfiles': logfiles, 'output': captured_output,
            'dev_pkgs': dev_pkgs}


message = """\
# Please describe the issue you are wishing to report. What did you expect to
# happen? What actually happened? Does this issue occur every time you use this
# function?

# Lines that start with a '#' will be ignored. Save the session and exit to
# store the description. Press "i" to be begin typing, then "Esc" followed by
# ":wq" to exit.
"""
